From 8e3b57320a46aa1b0bc6fdeef6c26e8d35f2936d Mon Sep 17 00:00:00 2001
From: Pierre-Hugues Husson <phh@phh.me>
Date: Sun, 18 Dec 2022 18:20:40 -0500
Subject: [PATCH 31/40] FOD support for Asus, Samsung recent Xiaomi and
 RedMagic 8 devices

Thanks Asus for providing a free device to make this support
And thanks @davigamer987 for donating enough to get a Samsung FOD device
to make this

14QPR2 note: Forced legacy/pre-"UdfpsRefactor"
Thanks @jgudec for Xiaomi support
Thanks @boydaihungst for Redmagic 6 support

Co-authored-by: jgudec <jakov.gudec@gmail.com>
Co-authored-by: Huy Hoang
Change-Id: Ibd0f9ea8fba584a38c060fd9271549a5e106b4eb

Also include commits:
fix(fod): Extra Dim overlap fod overlay
Fix Xiaomi custom vendors implementing fingerprint properly
Also override UDFPS infos on AIDL fingerprints -- needed for FP on S24
Try catch the Xiaomi calls
Typo in observing Samsung brightness
---
 packages/SystemUI/Android.bp                  |    4 +
 .../systemui/biometrics/UdfpsController.java  |   76 +-
 .../biometrics/UdfpsControllerOverlay.kt      |    7 +-
 .../android/systemui/biometrics/UdfpsView.kt  |  243 +++-
 .../shared/DeviceEntryUdfpsRefactor.kt        |    2 +-
 services/core/Android.bp                      |    9 +-
 .../server/biometrics/AuthService.java        |  296 ++++-
 .../server/biometrics/AuthService.java.save   | 1146 +++++++++++++++++
 .../fingerprint/FingerprintService.java       |    3 +-
 .../fingerprint/aidl/FingerprintProvider.java |   26 +-
 10 files changed, 1784 insertions(+), 28 deletions(-)
 create mode 100644 services/core/java/com/android/server/biometrics/AuthService.java.save

diff --git a/packages/SystemUI/Android.bp b/packages/SystemUI/Android.bp
index da2513e6b2bc..74a35b1edbea 100644
--- a/packages/SystemUI/Android.bp
+++ b/packages/SystemUI/Android.bp
@@ -159,6 +159,10 @@ android_library {
         "LowLightDreamLib",
         "motion_tool_lib",
         "notification_flags_lib",
+        "vendor.goodix.hardware.biometrics.fingerprint-V2.1-java",
+        "vendor.xiaomi.hw.touchfeature-V1.0-java",
+        "vendor.xiaomi.hardware.fingerprintextension-V1.0-java",
+        "vendor.nubia.ifaa-V1.0-java",
         "PlatformComposeCore",
         "PlatformComposeSceneTransitionLayout",
         "androidx.compose.runtime_runtime",
diff --git a/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsController.java b/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsController.java
index 91fecbca388c..5b169bc844a4 100644
--- a/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsController.java
+++ b/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsController.java
@@ -46,12 +46,14 @@ import android.hardware.fingerprint.FingerprintSensorProperties;
 import android.hardware.fingerprint.FingerprintSensorPropertiesInternal;
 import android.hardware.fingerprint.IUdfpsOverlayController;
 import android.hardware.fingerprint.IUdfpsOverlayControllerCallback;
+import android.hardware.display.ColorDisplayManager;
 import android.hardware.input.InputManager;
 import android.net.Uri;
 import android.os.Build;
 import android.os.Handler;
 import android.os.PowerManager;
 import android.os.Trace;
+import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.os.VibrationAttributes;
 import android.os.VibrationEffect;
@@ -125,8 +127,12 @@ import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.concurrent.Executor;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
 
 import javax.inject.Inject;
+import vendor.nubia.ifaa.V1_0.IIfaa;
 
 import kotlinx.coroutines.CoroutineScope;
 import kotlinx.coroutines.ExperimentalCoroutinesApi;
@@ -193,6 +199,8 @@ public class UdfpsController implements DozeReceiver, Dumpable {
     @NonNull private final AuthController mAuthController;
     @NonNull private final SelectedUserInteractor mSelectedUserInteractor;
     @NonNull private final FpsUnlockTracker mFpsUnlockTracker;
+    @NonNull private final ColorDisplayManager mColorDisplayManager;
+    private boolean mIgnoreExtraDim;
     private final boolean mIgnoreRefreshRate;
     private final KeyguardTransitionInteractor mKeyguardTransitionInteractor;
 
@@ -281,6 +289,47 @@ public class UdfpsController implements DozeReceiver, Dumpable {
         }
     };
 
+    // Nubia 6 series fingerprint control command
+    // cmd = 13 -> finger down
+    // cmd = 14 -> after UI ready
+    // cmd = 15 -> finger up
+    public byte[] processCmd(int cmd, int param1, int param2, byte[] send_buf, int length) {
+        try {
+            if (cmd == 999) {
+                Log.d(TAG, "processCmd: 999");
+                return null;
+            }
+            ArrayList<Byte> sendList = new ArrayList<>();
+            if (send_buf != null) {
+                for (byte b : send_buf) {
+                    sendList.add(Byte.valueOf(b));
+                }
+            }
+            if (send_buf == null) {
+                Log.d(TAG, "FingerprintService send_buf = " + send_buf);
+            }
+            IIfaa iIfaaDaemon = IIfaa.getService();
+            if (iIfaaDaemon == null) {
+                Log.d(TAG, "processCmd: no iIfaaDaemon!");
+                return null;
+            }
+            ArrayList<Byte> resultList = iIfaaDaemon.processCmd(cmd, param1, param2, sendList, length);
+            int n = resultList.size();
+            Log.d(TAG, "FingerprintService result length n = " + n);
+            if (n == 0) {
+                return null;
+            }
+            byte[] result = new byte[n];
+            for (int i = 0; i < n; i++) {
+                result[i] = resultList.get(i).byteValue();
+            }
+            return result;
+        } catch (Exception e) {
+            e.printStackTrace();
+            return null;
+        }
+    };
+
     private ConfigurationController.ConfigurationListener mConfigurationListener =
             new ConfigurationController.ConfigurationListener() {
                 @Override
@@ -748,7 +797,8 @@ public class UdfpsController implements DozeReceiver, Dumpable {
             @NonNull UdfpsOverlayInteractor udfpsOverlayInteractor,
             @NonNull PowerInteractor powerInteractor,
             @Application CoroutineScope scope,
-            @NonNull AuthController authController) {
+            @NonNull AuthController authController,
+            @NonNull ColorDisplayManager colorDisplayManager) {
         mContext = context;
         mExecution = execution;
         mVibrator = vibrator;
@@ -792,6 +842,7 @@ public class UdfpsController implements DozeReceiver, Dumpable {
         mFpsUnlockTracker = fpsUnlockTracker;
         mFpsUnlockTracker.startTracking();
         mKeyguardTransitionInteractor = keyguardTransitionInteractor;
+        mColorDisplayManager = colorDisplayManager;
 
         mTouchProcessor = singlePointerTouchProcessor;
         mSessionTracker = sessionTracker;
@@ -959,7 +1010,10 @@ public class UdfpsController implements DozeReceiver, Dumpable {
 
     private void showUdfpsOverlay(@NonNull UdfpsControllerOverlay overlay) {
         mExecution.assertIsMainThread();
-
+        mIgnoreExtraDim = mColorDisplayManager.isReduceBrightColorsActivated();
+        if (mIgnoreExtraDim) {
+            Log.d(TAG, "Current extra dim state (showUdfpsOverlay): " + mIgnoreExtraDim);
+        }
         mOverlay = overlay;
         final int requestReason = overlay.getRequestReason();
 
@@ -1255,6 +1309,10 @@ public class UdfpsController implements DozeReceiver, Dumpable {
             mSmartPixelsFlag = true;
         }
         if (isOptical()) {
+            if (mIgnoreExtraDim) {
+                mColorDisplayManager.setReduceBrightColorsActivated(false);
+                Log.d(TAG, "Extra dim disabled");
+            }
             mLatencyTracker.onActionStart(ACTION_UDFPS_ILLUMINATE);
         }
         if (getBiometricSessionType() == SESSION_KEYGUARD) {
@@ -1286,10 +1344,16 @@ public class UdfpsController implements DozeReceiver, Dumpable {
                 }
             }
         }
+        if(SystemProperties.get("ro.vendor.build.fingerprint").contains("nubia/NX669")) {
+          processCmd(13, 0, 0, new byte[0], 0);
+        }
 
         for (Callback cb : mCallbacks) {
             cb.onFingerDown();
         }
+        if(SystemProperties.get("ro.vendor.build.fingerprint").contains("nubia/NX669")) {
+          processCmd(14, 0, 0, new byte[0], 0);
+        }
         if (mUdfpsAnimation != null) {
             mUdfpsAnimation.show();
         }
@@ -1334,8 +1398,16 @@ public class UdfpsController implements DozeReceiver, Dumpable {
         }
 
         if (mOnFingerDown) {
+            if (mIgnoreExtraDim && isOptical()) {
+                mColorDisplayManager.setReduceBrightColorsActivated(true);
+                Log.d(TAG, "Extra dim restored");
+            }
             mFingerprintManager.onPointerUp(requestId, mSensorProps.sensorId, pointerId, x,
                     y, minor, major, orientation, time, gestureStart, isAod);
+            if(SystemProperties.get("ro.vendor.build.fingerprint").contains("nubia/NX669")) {
+                processCmd(15, 0, 0, new byte[0], 0);
+            }
+
             for (Callback cb : mCallbacks) {
                 cb.onFingerUp();
             }
diff --git a/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsControllerOverlay.kt b/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsControllerOverlay.kt
index 6dfb6437cc79..f6549e3fb572 100644
--- a/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsControllerOverlay.kt
+++ b/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsControllerOverlay.kt
@@ -176,7 +176,9 @@ class UdfpsControllerOverlay @JvmOverloads constructor(
         gravity = android.view.Gravity.TOP or android.view.Gravity.LEFT
         layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS
         flags = (Utils.FINGERPRINT_OVERLAY_LAYOUT_PARAM_FLAGS or
-                WindowManager.LayoutParams.FLAG_SPLIT_TOUCH)
+                WindowManager.LayoutParams.FLAG_SPLIT_TOUCH) or
+                WindowManager.LayoutParams.FLAG_DIM_BEHIND
+        dimAmount = 0.0f
         privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_TRUSTED_OVERLAY
         // Avoid announcing window title.
         accessibilityTitle = " "
@@ -286,6 +288,9 @@ class UdfpsControllerOverlay @JvmOverloads constructor(
 
                         addViewNowOrLater(this, animation)
                         sensorRect = sensorBounds
+                        dimUpdate = {
+                            windowManager.updateViewLayout(this, coreLayoutParams.updateDimensions(animation).apply { dimAmount = it })
+                        }
                     }
                 }
                 getTouchOverlay()?.apply {
diff --git a/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsView.kt b/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsView.kt
index ecd20d78f5d0..56754210c99b 100644
--- a/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsView.kt
+++ b/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsView.kt
@@ -19,18 +19,36 @@ import android.content.Context
 import android.graphics.Canvas
 import android.graphics.Color
 import android.graphics.Paint
+import android.graphics.PixelFormat
+import android.graphics.PointF
 import android.graphics.Rect
 import android.graphics.RectF
+import android.os.FileObserver
 import android.provider.Settings
 import android.os.UserHandle;
 import android.util.AttributeSet
 import android.util.Log
 import android.view.MotionEvent
+import android.view.SurfaceHolder
+import android.view.SurfaceView
+import android.view.ViewGroup
 import android.view.Surface
 import android.widget.FrameLayout
 import com.android.systemui.biometrics.shared.model.UdfpsOverlayParams
 import com.android.systemui.doze.DozeReceiver
 import com.android.systemui.res.R
+import java.io.File
+import java.io.FileNotFoundException
+
+import vendor.goodix.hardware.biometrics.fingerprint.V2_1.IGoodixFingerprintDaemon
+
+import vendor.xiaomi.hw.touchfeature.V1_0.ITouchFeature
+import vendor.xiaomi.hardware.fingerprintextension.V1_0.IXiaomiFingerprint
+
+import android.os.Handler
+import android.os.HandlerThread
+
+import vendor.nubia.ifaa.V1_0.IIfaa
 
 private const val TAG = "UdfpsView"
 
@@ -41,6 +59,55 @@ class UdfpsView(
     context: Context,
     attrs: AttributeSet?
 ) : FrameLayout(context, attrs), DozeReceiver {
+    private var currentOnIlluminatedRunnable: Runnable? = null
+    private val mySurfaceView = SurfaceView(context)
+    init {
+        mySurfaceView.setVisibility(INVISIBLE)
+        mySurfaceView.setZOrderOnTop(true)
+        addView(mySurfaceView, FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
+        mySurfaceView.holder.addCallback(object: SurfaceHolder.Callback{
+            override fun surfaceCreated(p0: SurfaceHolder) {
+                Log.d("PHH", "Surface created!")
+                val paint = Paint(0 /* flags */);
+                paint.setAntiAlias(true);
+                paint.setStyle(Paint.Style.FILL);
+                val colorStr = android.os.SystemProperties.get("persist.sys.phh.fod_color", "00ff00");
+                try {
+                    val parsedColor = Color.parseColor("#" + colorStr);
+                    val r = (parsedColor shr 16) and 0xff;
+                    val g = (parsedColor shr  8) and 0xff;
+                    val b = (parsedColor shr  0) and 0xff;
+                    paint.setARGB(255, r, g, b);
+                } catch(t: Throwable) {
+                    Log.d("PHH", "Failed parsing color #" + colorStr, t);
+                }
+                var canvas: Canvas? = null
+                try {
+                    canvas = p0.lockCanvas();
+                    Log.d("PHH", "Surface dimensions ${canvas.getWidth()*1.0f} ${canvas.getHeight()*1.0f}")
+                    canvas.drawOval(RectF(overlayParams.sensorBounds), paint);
+                } finally {
+                    // Make sure the surface is never left in a bad state.
+                    if (canvas != null) {
+                        p0.unlockCanvasAndPost(canvas);
+                    }
+                }
+
+                currentOnIlluminatedRunnable?.run()
+            }
+
+            override fun surfaceChanged(p0: SurfaceHolder, p1: Int, p2: Int, p3: Int) {
+                Log.d("PHH", "Got surface size $p1 $p2 $p3")
+            }
+
+            override fun surfaceDestroyed(p0: SurfaceHolder) {
+                Log.d("PHH", "Surface destroyed!")
+            }
+        })
+        mySurfaceView.holder.setFormat(PixelFormat.RGBA_8888)
+
+    }
+
     // sensorRect may be bigger than the sensor. True sensor dimensions are defined in
     // overlayParams.sensorBounds
     var sensorRect = Rect()
@@ -59,6 +126,8 @@ class UdfpsView(
     /** Parameters that affect the position and size of the overlay. */
     var overlayParams = UdfpsOverlayParams()
 
+    var dimUpdate: (Float) -> Unit = {}
+
     /** Debug message. */
     var debugMessage: String? = null
         set(value) {
@@ -130,37 +199,177 @@ class UdfpsView(
         }
     }
 
+    fun goodixCmd(id: Int) {
+        val goodixSvc = IGoodixFingerprintDaemon.getService()
+        if(goodixSvc != null) {
+            goodixSvc.sendCommand(id, ArrayList(), { returnCode, resultData -> {
+                Log.e("PHH-Enroll", "Goodix send command returned code "+ returnCode);
+            }});
+        }
+    }
+
+    val asusGhbmOnAchieved = "/sys/class/drm/ghbm_on_achieved"
+    var hasAsusGhbm = File(asusGhbmOnAchieved).exists()
+    var samsungActualMaskBrightness = "/sys/class/lcd/panel/actual_mask_brightness"
+    val hasSamsungMask = File(samsungActualMaskBrightness).exists()
+    var fodFileObserver: FileObserver? = null
+
+    val xiaomiDispParam = "/sys/class/mi_display/disp-DSI-0/disp_param"
+    var hasXiaomiLhbm = try {
+            val xiaomiFingerprintService = IXiaomiFingerprint.getService()
+            File(xiaomiDispParam).exists() && xiaomiFingerprintService != null
+        } catch(e: Exception) {
+            false
+        }
+
+    private val handlerThread = HandlerThread("UDFPS").also { it.start() }
+    val myHandler = Handler(handlerThread.looper)
+
+    // This file contain current hbm value
+    val nubiaHbmState = "/sys/kernel/lcd_enhance/hbm_state"
+    var hasNubiaHbm = File(nubiaHbmState).exists()
+
     fun configureDisplay(onDisplayConfigured: Runnable) {
         isDisplayConfigured = true
         animationViewController?.onDisplayConfiguring()
-        val gView = ghbmView
-        if (gView != null) {
-            gView.setGhbmIlluminationListener(this::doIlluminate)
-            gView.visibility = VISIBLE
-            gView.startGhbmIllumination(onDisplayConfigured)
+        mUdfpsDisplayMode?.enable(onDisplayConfigured)
+
+        mySurfaceView.setVisibility(VISIBLE)
+        Log.d("PHH", "setting surface visible!")
+
+        val brightnessFiles = listOf(
+            File("/sys/class/backlight/panel/brightness"),
+            File("/sys/class/backlight/panel0-backlight/brightness"),
+            File("/sys/devices/platform/soc/soc:mtk_leds/leds/lcd-backlight/brightness")
+        )
+        val maxBrightnessFiles = listOf(
+            File("/sys/class/backlight/panel/max_brightness"),
+            File("/sys/class/backlight/panel0-backlight/max_brightness"),
+            File("/sys/devices/platform/soc/soc:mtk_leds/leds/lcd-backlight/max_brightness")
+        )
+
+        var brightness: Double = 0.0
+        var maxBrightness: Double = 0.0
+        var bmFilesExist: Boolean = false
+
+        brightnessFiles.zip(maxBrightnessFiles) {bFile, mFile ->
+            if (bFile.exists() && mFile.exists()) {
+                bmFilesExist = true
+                brightness = bFile.readText().toDouble()
+                maxBrightness = mFile.readText().toDouble()
+            }
+        }
+
+        val dim = if (bmFilesExist) {
+            1.0 - Math.pow( (brightness / maxBrightness), 1/2.3);
         } else {
-            doIlluminate(null /* surface */, onDisplayConfigured)
+            0.0
         }
-    }
 
-    private fun doIlluminate(surface: Surface?, onDisplayConfigured: Runnable?) {
-        if (ghbmView != null && surface == null) {
-            Log.e(TAG, "doIlluminate | surface must be non-null for GHBM")
+        // Assume HBM is max brightness
+        Log.d("PHH-Enroll", "Brightness is $brightness / $maxBrightness, setting dim to $dim")
+        if (hasAsusGhbm) {
+            dimUpdate(dim.toFloat())
+        }
+        if (hasSamsungMask) {
+            dimUpdate(dim.toFloat())
         }
 
-        mUdfpsDisplayMode?.enable {
-            onDisplayConfigured?.run()
-            ghbmView?.drawIlluminationDot(RectF(sensorRect))
+        if(android.os.SystemProperties.get("ro.vendor.build.fingerprint").contains("ASUS")) {
+            goodixCmd(200001)
         }
+
+        if(hasXiaomiLhbm){
+            Log.d("PHH-Enroll", "Xiaomi scenario in UdfpsView reached!")
+            mySurfaceView.setVisibility(INVISIBLE)
+
+            try {
+                IXiaomiFingerprint.getService().extCmd(android.os.SystemProperties.getInt("persist.phh.xiaomi.fod.enrollment.id", 4), 1);
+            } catch(t: Throwable) {}
+            var res = try { ITouchFeature.getService().setTouchMode(0, 10, 1) } catch(t: Throwable){ -1 }
+            if(res != 0){
+                Log.d("PHH-Enroll", "SetTouchMode 10,1 was NOT executed successfully. Res is " + res)
+            }
+
+            myHandler.postDelayed({
+                var ret200 = try { ITouchFeature.getService().setTouchMode(0, 10, 1); } catch(t: Throwable) { -1 }
+
+                if(ret200 != 0){
+                    Log.d("PHH-Enroll", "myHandler.postDelayed 200ms -SetTouchMode was NOT executed successfully. Ret is " + ret200)
+                }
+
+                myHandler.postDelayed({
+                    Log.d("PHH-Enroll", "myHandler.postDelayed 600ms - line prior to setTouchMode 10,0")
+                    var ret600 = try { ITouchFeature.getService().setTouchMode(0, 10, 0); } catch(t: Throwable) { -1 }
+
+                    if(ret600 != 0){
+                        Log.d("PHH-Enroll", "myHandler.postDelayed 600ms -SetTouchMode 10,0 was NOT executed successfully. Ret is " + ret600)
+                    }
+                }, 600)
+            }, 200)
+        }
+          if(hasNubiaHbm) {
+            Log.d("PHH-Enroll", "Nubia scenario in UdfpsView reached!")
+            File(nubiaHbmState).writeText("4095")
+          }
+
     }
 
     fun unconfigureDisplay() {
         isDisplayConfigured = false
         animationViewController?.onDisplayUnconfigured()
-        ghbmView?.let { view ->
-            view.setGhbmIlluminationListener(null)
-            view.visibility = INVISIBLE
-        }
         mUdfpsDisplayMode?.disable(null /* onDisabled */)
+
+        if (hasAsusGhbm) {
+            fodFileObserver = object: FileObserver(asusGhbmOnAchieved, FileObserver.MODIFY) {
+                override fun onEvent(event: Int, path: String?): Unit {
+                    if (path == null) return
+                    Log.d("PHH-Enroll", "Asus ghbm event")
+                    try {
+                        val spotOn = File(asusGhbmOnAchieved).readText().toInt()
+                        if(spotOn == 0) {
+                            dimUpdate(0.0f)
+                            fodFileObserver?.stopWatching()
+                            fodFileObserver = null
+                        }
+                    } catch(e: Exception) {
+                        Log.d("PHH-Enroll", "Failed dimpdate off", e)
+                    }
+                }
+            };
+            fodFileObserver?.startWatching();
+        } else if (hasSamsungMask) {
+            fodFileObserver = object: FileObserver(samsungActualMaskBrightness, FileObserver.MODIFY) {
+                override fun onEvent(event: Int, path: String?): Unit {
+                    if (path == null) return
+                    Log.d("PHH-Enroll", "samsung mask brightness event")
+                    try {
+                        val spotOn = File(samsungActualMaskBrightness).readText().toInt()
+                        if(spotOn == 0) {
+                            dimUpdate(0.0f)
+                            fodFileObserver?.stopWatching()
+                            fodFileObserver = null
+                        }
+                    } catch(e: Exception) {
+                        Log.d("PHH-Enroll", "Failed dimpdate off", e)
+                    }
+                }
+            };
+            fodFileObserver?.startWatching();
+        } else if(hasXiaomiLhbm) {
+            IXiaomiFingerprint.getService().extCmd(android.os.SystemProperties.getInt("persist.phh.xiaomi.fod.enrollment.id", 4), 0);
+            ITouchFeature.getService().setTouchMode(0, 10, 0);
+        } else if(hasNubiaHbm) {
+            Log.d("PHH-Enroll", "Nubia Restore brightness")
+            File(nubiaHbmState).writeText(File("/sys/class/backlight/panel0-backlight/brightness").readText())
+        } else {
+            dimUpdate(0.0f)
+        }
+
+        mySurfaceView.setVisibility(INVISIBLE)
+        Log.d("PHH", "setting surface invisible!")
+        if(android.os.SystemProperties.get("ro.vendor.build.fingerprint").contains("ASUS")) {
+            goodixCmd(200003)
+        }
     }
 }
diff --git a/packages/SystemUI/src/com/android/systemui/deviceentry/shared/DeviceEntryUdfpsRefactor.kt b/packages/SystemUI/src/com/android/systemui/deviceentry/shared/DeviceEntryUdfpsRefactor.kt
index b5d5803ca6fb..68f74f3ed6f3 100644
--- a/packages/SystemUI/src/com/android/systemui/deviceentry/shared/DeviceEntryUdfpsRefactor.kt
+++ b/packages/SystemUI/src/com/android/systemui/deviceentry/shared/DeviceEntryUdfpsRefactor.kt
@@ -33,7 +33,7 @@ object DeviceEntryUdfpsRefactor {
     /** Is the refactor enabled */
     @JvmStatic
     inline val isEnabled
-        get() = Flags.deviceEntryUdfpsRefactor()
+        get() = false //Flags.deviceEntryUdfpsRefactor()
 
     /**
      * Called to ensure code is only run when the flag is enabled. This protects users from the
diff --git a/services/core/Android.bp b/services/core/Android.bp
index 9cd1377d1705..2deaa518b9c3 100644
--- a/services/core/Android.bp
+++ b/services/core/Android.bp
@@ -252,7 +252,14 @@ java_library_static {
         "com_android_wm_shell_flags_lib",
         "com.android.server.utils_aconfig-java",
         "service-jobscheduler-deviceidle.flags-aconfig-java",
-        "vendor.samsung.hardware.sysinput-V1.2-java", // HIDL
+        // HIDL
+        "vendor.mediatek.hardware.mtkpower-V1.1-java",
+        "vendor.samsung.hardware.sysinput-V1.2-java",
+        "vendor.goodix.hardware.biometrics.fingerprint-V2.1-java",
+        "vendor.samsung.hardware.biometrics.fingerprint-V3.0-java",
+        "vendor.oplus.hardware.biometrics.fingerprint-V2.1-java",
+        "vendor.oppo.hardware.biometrics.fingerprint-V2.1-java",
+        "vendor.xiaomi.hardware.fingerprintextension-V1.0-java",
         "policy_flags_lib",
         "net_flags_lib",
         "stats_flags_lib",
diff --git a/services/core/java/com/android/server/biometrics/AuthService.java b/services/core/java/com/android/server/biometrics/AuthService.java
index eef5e79e4ed5..b1f06482dc19 100644
--- a/services/core/java/com/android/server/biometrics/AuthService.java
+++ b/services/core/java/com/android/server/biometrics/AuthService.java
@@ -85,6 +85,25 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
+import android.hardware.display.DisplayManager;
+
+import android.graphics.Point;
+import android.text.TextUtils;
+import android.util.DisplayMetrics;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.PrintWriter;
+
+import android.os.FileObserver;
+import android.os.Build;
+
+import vendor.samsung.hardware.biometrics.fingerprint.V3_0.ISehBiometricsFingerprint;
+import vendor.goodix.hardware.biometrics.fingerprint.V2_1.IGoodixFingerprintDaemon;
+import vendor.samsung.hardware.sysinput.V1_0.ISehSysInputDev;
+
+import vendor.xiaomi.hardware.fingerprintextension.V1_0.IXiaomiFingerprint;
+
 /**
  * System service that provides an interface for authenticating with biometrics and
  * PIN/pattern/password to BiometricPrompt and lock screen.
@@ -103,6 +122,11 @@ public class AuthService extends SystemService {
     @VisibleForTesting
     final IAuthService.Stub mImpl;
 
+    private FileObserver fodFileObserver = null;
+    private ISehBiometricsFingerprint mSamsungFingerprint = null;
+
+    private IXiaomiFingerprint mXiaomiFingerprint = null;
+
     /**
      * Class for injecting dependencies into AuthService.
      * TODO(b/141025588): Replace with a dependency injection framework (e.g. Guice, Dagger).
@@ -765,11 +789,11 @@ public class AuthService extends SystemService {
             final int firstApiLevel = SystemProperties.getInt(SYSPROP_FIRST_API_LEVEL, 0);
             final int apiLevel = SystemProperties.getInt(SYSPROP_API_LEVEL, firstApiLevel);
             String[] configStrings = mInjector.getConfiguration(getContext());
-            if (configStrings.length == 0 && apiLevel <= Build.VERSION_CODES.R) {
+            if (configStrings.length == 0) {
                 // For backwards compatibility with R where biometrics could work without being
                 // configured in config_biometric_sensors. In the absence of a vendor provided
                 // configuration, we assume the weakest biometric strength (i.e. convenience).
-                Slog.w(TAG, "Found R vendor partition without config_biometric_sensors");
+                Slog.w(TAG, "Found vendor partition without config_biometric_sensors");
                 configStrings = generateRSdkCompatibleConfiguration();
             }
             hidlConfigs = new SensorConfig[configStrings.length];
@@ -788,6 +812,102 @@ public class AuthService extends SystemService {
         }
 
         mInjector.publishBinderService(this, mImpl);
+        try {
+            mSamsungFingerprint = ISehBiometricsFingerprint.getService();
+            android.util.Log.e("PHH", "Got samsung fingerprint HAL");
+        } catch(Exception e) {
+            android.util.Log.e("PHH", "Failed getting Samsung fingerprint HAL", e);
+        }
+        try {
+            mXiaomiFingerprint = IXiaomiFingerprint.getService();
+            android.util.Log.e("PHH", "Got xiaomi fingerprint HAL");
+        } catch(Exception e) {
+            android.util.Log.e("PHH", "Failed getting xiaomi fingerprint HAL", e);
+        }
+        if(samsungHasCmd("fod_enable") && mSamsungFingerprint != null) {
+            samsungCmd("fod_enable,1,1,0");
+            String actualMaskBrightnessPath = "/sys/class/lcd/panel/actual_mask_brightness";
+            android.util.Log.e("PHH-Enroll", "Reading actual brightness file gives " + readFile(actualMaskBrightnessPath));
+            fodFileObserver = new FileObserver(actualMaskBrightnessPath, FileObserver.MODIFY) {
+                @Override
+                public void onEvent(int event, String path) {
+                    String actualMask = readFile(actualMaskBrightnessPath);
+                    try {
+                        mSamsungFingerprint = ISehBiometricsFingerprint.getService();
+                    } catch(Exception e) {}
+                    Slog.d("PHH-Enroll", "New actual mask brightness is " + actualMask);
+                    try {
+                        int eventReq = 0;
+                        if("0".equals(actualMask)) {
+                            eventReq = 1; //released
+                        } else {
+                            eventReq = 2; //pressed
+                        }
+                        if(mSamsungFingerprint != null) {
+                            mSamsungFingerprint.sehRequest(22 /* SEM_FINGER_STATE */, eventReq, new java.util.ArrayList<Byte>(),
+                                    (int retval, java.util.ArrayList<Byte> out) -> {} );
+                        }
+                    } catch(Exception e) {
+                        Slog.d("PHH-Enroll", "Failed setting samsung event for mask observer", e);
+                    }
+                }
+            };
+            fodFileObserver.startWatching();
+        }
+
+        String asusGhbmOnAchieved = "/sys/class/drm/ghbm_on_achieved";
+        if( (new File(asusGhbmOnAchieved)).exists()) {
+            fodFileObserver = new FileObserver(asusGhbmOnAchieved, FileObserver.MODIFY) {
+                boolean wasOn = false;
+                @Override
+                public void onEvent(int event, String path) {
+                    String spotOn = readFile(asusGhbmOnAchieved);
+                    if("1".equals(spotOn)) {
+                        if(!wasOn) {
+                            try {
+                                IGoodixFingerprintDaemon goodixDaemon = IGoodixFingerprintDaemon.getService();
+
+                                //Send UI ready
+                                goodixDaemon.sendCommand(200002, new java.util.ArrayList<Byte>(), (returnCode, resultData) -> {
+                                    Slog.e(TAG, "Goodix send command touch pressed returned code "+ returnCode);
+                                });
+                            } catch(Throwable t) {
+                                Slog.d("PHH-Enroll", "Failed sending goodix command", t);
+                            }
+                        }
+                        wasOn = true;
+                    } else {
+                        wasOn = false;
+                    }
+                }
+            };
+            fodFileObserver.startWatching();
+        }
+
+        String xiaomiFodPressedStatusPath = "/sys/class/touch/touch_dev/fod_press_status";
+        if(new File(xiaomiFodPressedStatusPath).exists() && mXiaomiFingerprint != null) {
+            fodFileObserver = new FileObserver(xiaomiFodPressedStatusPath, FileObserver.MODIFY) {
+                @Override
+                public void onEvent(int event, String path) {
+                    String isFodPressed = readFile(xiaomiFodPressedStatusPath);
+                    Slog.d("PHH-Enroll", "Fod pressed status: " + isFodPressed);
+                    Slog.d("PHH-Enroll", "Within xiaomi scenario for FOD");
+
+                    try {
+                    if("0".equals(isFodPressed)) {
+                        Slog.d("PHH-Enroll", "Fod un-pressed!");
+                        mXiaomiFingerprint.extCmd(android.os.SystemProperties.getInt("phh.xiaomi.fod.enrollment.id", 4), 0);
+                    } else if("1".equals(isFodPressed)) {
+                        Slog.d("PHH-Enroll", "Fod pressed!");
+                        mXiaomiFingerprint.extCmd(android.os.SystemProperties.getInt("phh.xiaomi.fod.enrollment.id", 4), 1);
+                    }
+                    } catch(Exception e) {
+                        Slog.d("PHH-Enroll", "Failed Xiaomi async extcmd", e);
+                    }
+                }
+            };
+            fodFileObserver.startWatching();
+        }
     }
 
     private void registerAuthenticators() {
@@ -1039,18 +1159,123 @@ public class AuthService extends SystemService {
                 ? modality : (modality & ~BiometricAuthenticator.TYPE_CREDENTIAL);
     }
 
+    static public int[] dynamicUdfpsProps(Context ctxt) {
+        DisplayManager mDM = (DisplayManager) ctxt.getSystemService(Context.DISPLAY_SERVICE);
+        Point displayRealSize = new Point();
+        DisplayMetrics displayMetrics = new DisplayMetrics();
+        mDM.getDisplay(0).getRealSize(displayRealSize);
+        mDM.getDisplay(0).getMetrics(displayMetrics);
+
+        if(readFile("/sys/class/fingerprint/fingerprint/position") != null) {
+            try {
+            ISehSysInputDev s = ISehSysInputDev.getService();
+            s.getTspFodInformation(0, (a, b) -> {
+                Slog.d("PHH-Enroll", "TspFod info " + a + ", " + b);
+            });
+            s.getTspFodPosition(0, (a, b) -> {
+                Slog.d("PHH-Enroll", "TspFod info " + a + ", " + b);
+            });
+            }catch(Throwable t) {
+                Slog.d("PHH-Enroll", "heya ", t);
+            }
+
+
+            android.util.Log.d("PHH", "Samsung fingerprint");
+            String[] fodPositionArray = readFile("/sys/class/fingerprint/fingerprint/position").split(",");
+            float bottomMM = Float.parseFloat(fodPositionArray[0]);
+            float areaSizeMM = Float.parseFloat(fodPositionArray[5]);
+            float heightMM = Float.parseFloat(fodPositionArray[2]);
+            float bottomInch = bottomMM * 0.0393700787f;
+            float areaSizeInch = areaSizeMM * 0.0393700787f;
+            float heightInch = heightMM * 0.0393700787f;
+            int bottomPx = (int)(bottomInch * displayMetrics.ydpi);
+            int areaSizePx = (int)(areaSizeInch * displayMetrics.ydpi);
+            int midDistPx = (int)(areaSizeInch * displayMetrics.ydpi / 2.0f);
+
+            float mW = areaSizePx/2;
+            float mH = areaSizePx/2;
+            float mX = displayRealSize.x/2;
+            //float mY = displayRealSize.y - bottomPx - midDistPx;
+            float mY = displayRealSize.y - (bottomInch * displayMetrics.ydpi) - (areaSizeInch * displayMetrics.ydpi / 2.0f);
+
+            samsungCmd(String.format("fod_rect,%d,%d,%d,%d", (int)(mX - mW/2), (int)(mY - mW/2), (int)(mX + mW/2), (int)(mY + mW/2)));
+            Slog.d("PHH-Enroll", "Display real size is " + displayRealSize.y + ", dpy " + displayMetrics.ydpi);
+
+            int udfpsProps[] = new int[3];
+            udfpsProps[0] = (int)mX;
+            udfpsProps[1] = (int)mY;
+            udfpsProps[2] = (int)mW;
+
+            try {
+                mSamsungFingerprint = ISehBiometricsFingerprint.getService();
+                Slog.d("PHH-Enroll", "Samsung ask for sensor status");
+                mSamsungFingerprint.sehRequest(6, 0, new java.util.ArrayList(), (int retval, java.util.ArrayList<Byte> out) -> {
+                    Slog.d("PHH-Enroll", "Result is " + retval);
+                    for(int i=0; i<out.size(); i++) {
+                        Slog.d("PHH-Enroll", "\t" + i + ":" + out.get(i));
+                    }
+                } );
+                Slog.d("PHH-Enroll", "Samsung ask for sensor brightness value");
+                mSamsungFingerprint.sehRequest(32, 0, new java.util.ArrayList(), (int retval, java.util.ArrayList<Byte> out) -> {
+                    Slog.d("PHH-Enroll", "Result is " + retval);
+                    for(int i=0; i<out.size(); i++) {
+                        Slog.d("PHH-Enroll", "\t" + i + ":" + out.get(i));
+                    }
+                } );
+
+            } catch(Exception e) {
+                Slog.d("PHH-Enroll", "Failed setting samsung3.0 fingerprint recognition", e);
+            }
+            return udfpsProps;
+        }
+
+        if(android.os.SystemProperties.get("ro.vendor.build.fingerprint").contains("ASUS_I006D")) {
+            int udfpsProps[] = new int[3];
+            udfpsProps[0] = displayRealSize.x/2;
+            udfpsProps[1] = 1741;
+            udfpsProps[2] = 110;
+            return udfpsProps;
+        }
+
+       String fpLocation = android.os.SystemProperties.get("persist.vendor.sys.fp.fod.location.X_Y");
+       if(!TextUtils.isEmpty(fpLocation) && fpLocation.contains(",")) {
+            int[] udfpsProps = new int[3];
+            String[] coordinates = fpLocation.split(",");
+            udfpsProps[0] = displayRealSize.x/2;
+            udfpsProps[1] = Integer.parseInt(coordinates[1]) + 100;
+
+            String[] widthHeight = android.os.SystemProperties.get("persist.vendor.sys.fp.fod.size.width_height").split(",");
+
+            udfpsProps[2] = (Integer.parseInt(widthHeight[0]) /2);
+            return udfpsProps;
+        }
+
+        return new int[0];
+    }
 
     private FingerprintSensorPropertiesInternal getHidlFingerprintSensorProps(int sensorId,
             @BiometricManager.Authenticators.Types int strength) {
         // The existence of config_udfps_sensor_props indicates that the sensor is UDFPS.
-        final int[] udfpsProps = getContext().getResources().getIntArray(
+        int[] udfpsProps = getContext().getResources().getIntArray(
                 com.android.internal.R.array.config_udfps_sensor_props);
 
         // Non-empty workaroundLocations indicates that the sensor is SFPS.
         final List<SensorLocationInternal> workaroundLocations =
                 getWorkaroundSensorProps(getContext());
 
-        final boolean isUdfps = !ArrayUtils.isEmpty(udfpsProps);
+        boolean isUdfps = !ArrayUtils.isEmpty(udfpsProps);
+        if(!isUdfps) {
+            try {
+                udfpsProps = dynamicUdfpsProps(getContext());
+            } catch(Throwable t) {
+                Slog.e("PHH-Enroll", "Failed generating UDFPS props");
+            }
+        }
+        isUdfps = !ArrayUtils.isEmpty(udfpsProps);
+
+        if(udfpsProps.length > 0) {
+            Slog.d("PHH-Enroll", "Got udfps infos " + udfpsProps[0] + ", " + udfpsProps[1] + ", " + udfpsProps[2]);
+        }
 
         // config_is_powerbutton_fps indicates whether device has a power button fingerprint sensor.
         final boolean isPowerbuttonFps = getContext().getResources().getBoolean(
@@ -1118,4 +1343,67 @@ public class AuthService extends SystemService {
                 componentInfo, resetLockoutRequiresHardwareAuthToken,
                 resetLockoutRequiresChallenge);
     }
+
+   private static boolean samsungHasCmd(String cmd) {
+        try {
+            File f = new File("/sys/devices/virtual/sec/tsp/cmd_list");
+            if(!f.exists()) return false;
+
+            android.util.Log.d("PHH", "Managed to grab cmd list, checking...");
+            BufferedReader b = new BufferedReader(new FileReader(f));
+            String line = null;
+            while( (line = b.readLine()) != null) {
+                if(line.equals(cmd)) return true;
+            }
+            android.util.Log.d("PHH", "... nope");
+            return false;
+        } catch(Exception e) {
+            android.util.Log.d("PHH", "Failed reading cmd_list", e);
+            return false;
+        }
+    }
+
+    public static void samsungCmd(String cmd) {
+        try {
+            writeFile("/sys/devices/virtual/sec/tsp/cmd", cmd);
+
+            String status = readFile("/sys/devices/virtual/sec/tsp/cmd_status");
+            String ret = readFile("/sys/devices/virtual/sec/tsp/cmd_result");
+
+            android.util.Log.d("PHH", "Sending command " + cmd + " returned " + ret + ":" + status);
+        } catch(Exception e) {
+            android.util.Log.d("PHH", "Failed sending command " + cmd, e);
+        }
+    }
+
+    private static void writeFile(String path, String value) {
+        try {
+            PrintWriter writer = new PrintWriter(path, "UTF-8");
+            writer.println(value);
+            writer.close();
+        } catch(Exception e) {
+            android.util.Log.d("PHH", "Failed writing to " + path + ": " + value);
+        }
+    }
+
+    private static void writeFile(File file, String value) {
+        try {
+            PrintWriter writer = new PrintWriter(file, "UTF-8");
+            writer.println(value);
+            writer.close();
+        } catch(Exception e) {
+            android.util.Log.d("PHH", "Failed writing to " + file + ": " + value);
+        }
+    }
+
+    private static String readFile(String path) {
+        try {
+            File f = new File(path);
+
+            BufferedReader b = new BufferedReader(new FileReader(f));
+            return b.readLine();
+        } catch(Exception e) {
+            return null;
+        }
+    }
 }
diff --git a/services/core/java/com/android/server/biometrics/AuthService.java.save b/services/core/java/com/android/server/biometrics/AuthService.java.save
new file mode 100644
index 000000000000..d0cff2cc0dc3
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/AuthService.java.save
@@ -0,0 +1,1146 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.biometrics;
+
+
+// TODO(b/141025588): Create separate internal and external permissions for AuthService.
+// TODO(b/141025588): Get rid of the USE_FINGERPRINT permission.
+
+import static android.Manifest.permission.SET_BIOMETRIC_DIALOG_LOGO;
+import static android.Manifest.permission.TEST_BIOMETRIC;
+import static android.Manifest.permission.USE_BIOMETRIC;
+import static android.Manifest.permission.USE_BIOMETRIC_INTERNAL;
+import static android.Manifest.permission.USE_FINGERPRINT;
+import static android.hardware.biometrics.BiometricAuthenticator.TYPE_FACE;
+import static android.hardware.biometrics.BiometricAuthenticator.TYPE_FINGERPRINT;
+import static android.hardware.biometrics.BiometricAuthenticator.TYPE_IRIS;
+import static android.hardware.biometrics.BiometricAuthenticator.TYPE_NONE;
+import static android.hardware.biometrics.BiometricConstants.BIOMETRIC_ERROR_CANCELED;
+import static android.hardware.biometrics.BiometricManager.Authenticators;
+
+import static com.android.server.biometrics.sensors.fingerprint.aidl.FingerprintProvider.getWorkaroundSensorProps;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.app.AppOpsManager;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.hardware.biometrics.AuthenticationStateListener;
+import android.hardware.biometrics.BiometricAuthenticator;
+import android.hardware.biometrics.BiometricManager;
+import android.hardware.biometrics.ComponentInfoInternal;
+import android.hardware.biometrics.Flags;
+import android.hardware.biometrics.IAuthService;
+import android.hardware.biometrics.IBiometricEnabledOnKeyguardCallback;
+import android.hardware.biometrics.IBiometricService;
+import android.hardware.biometrics.IBiometricServiceReceiver;
+import android.hardware.biometrics.IInvalidationCallback;
+import android.hardware.biometrics.ITestSession;
+import android.hardware.biometrics.ITestSessionCallback;
+import android.hardware.biometrics.PromptInfo;
+import android.hardware.biometrics.SensorLocationInternal;
+import android.hardware.biometrics.SensorPropertiesInternal;
+import android.hardware.biometrics.face.IFace;
+import android.hardware.biometrics.fingerprint.IFingerprint;
+import android.hardware.face.FaceSensorConfigurations;
+import android.hardware.face.FaceSensorProperties;
+import android.hardware.face.FaceSensorPropertiesInternal;
+import android.hardware.face.IFaceService;
+import android.hardware.fingerprint.FingerprintSensorConfigurations;
+import android.hardware.fingerprint.FingerprintSensorProperties;
+import android.hardware.fingerprint.FingerprintSensorPropertiesInternal;
+import android.hardware.fingerprint.IFingerprintService;
+import android.hardware.iris.IIrisService;
+import android.os.Binder;
+import android.os.Build;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.util.Slog;
+
+import com.android.internal.R;
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.util.ArrayUtils;
+import com.android.server.SystemService;
+import com.android.server.companion.virtual.VirtualDeviceManagerInternal;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import android.hardware.display.DisplayManager;
+
+import android.graphics.Point;
+import android.text.TextUtils;
+import android.util.DisplayMetrics;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.PrintWriter;
+
+import android.os.FileObserver;
+import android.os.Build;
+
+import vendor.samsung.hardware.biometrics.fingerprint.V3_0.ISehBiometricsFingerprint;
+import vendor.goodix.hardware.biometrics.fingerprint.V2_1.IGoodixFingerprintDaemon;
+import vendor.samsung.hardware.sysinput.V1_0.ISehSysInputDev;
+
+import vendor.xiaomi.hardware.fingerprintextension.V1_0.IXiaomiFingerprint;
+
+/**
+ * System service that provides an interface for authenticating with biometrics and
+ * PIN/pattern/password to BiometricPrompt and lock screen.
+ */
+public class AuthService extends SystemService {
+    private static final String TAG = "AuthService";
+    private static final String SETTING_HIDL_DISABLED =
+            "com.android.server.biometrics.AuthService.hidlDisabled";
+    private static final int DEFAULT_HIDL_DISABLED = 0;
+    private static final String SYSPROP_FIRST_API_LEVEL = "ro.board.first_api_level";
+    private static final String SYSPROP_API_LEVEL = "ro.board.api_level";
+
+    private final Injector mInjector;
+
+    private IBiometricService mBiometricService;
+    @VisibleForTesting
+    final IAuthService.Stub mImpl;
+
+    private FileObserver fodFileObserver = null;
+    private ISehBiometricsFingerprint mSamsungFingerprint = null;
+
+    private IXiaomiFingerprint mXiaomiFingerprint = null;
+
+    /**
+     * Class for injecting dependencies into AuthService.
+     * TODO(b/141025588): Replace with a dependency injection framework (e.g. Guice, Dagger).
+     */
+    @VisibleForTesting
+    public static class Injector {
+
+        /**
+         * Allows to mock BiometricService for testing.
+         */
+        @VisibleForTesting
+        public IBiometricService getBiometricService() {
+            return IBiometricService.Stub.asInterface(
+                    ServiceManager.getService(Context.BIOMETRIC_SERVICE));
+        }
+
+        /**
+         * Allows to stub publishBinderService(...) for testing.
+         */
+        @VisibleForTesting
+        public void publishBinderService(AuthService service, IAuthService.Stub impl) {
+            service.publishBinderService(Context.AUTH_SERVICE, impl);
+        }
+
+        /**
+         * Allows to test with various device sensor configurations.
+         */
+        @VisibleForTesting
+        public String[] getConfiguration(Context context) {
+            return context.getResources().getStringArray(R.array.config_biometric_sensors);
+        }
+
+        /**
+         * Allows to test with various device sensor configurations.
+         */
+        @VisibleForTesting
+        public String[] getFingerprintConfiguration(Context context) {
+            return getConfiguration(context);
+        }
+
+        /**
+         * Allows to test with various device sensor configurations.
+         */
+        @VisibleForTesting
+        public String[] getFaceConfiguration(Context context) {
+            return getConfiguration(context);
+        }
+
+        /**
+         * Allows to test with various device sensor configurations.
+         */
+        @VisibleForTesting
+        public String[] getIrisConfiguration(Context context) {
+            return getConfiguration(context);
+        }
+
+        /**
+         * Allows us to mock FingerprintService for testing
+         */
+        @VisibleForTesting
+        public IFingerprintService getFingerprintService() {
+            return IFingerprintService.Stub.asInterface(
+                    ServiceManager.getService(Context.FINGERPRINT_SERVICE));
+        }
+
+        /**
+         * Allows us to mock FaceService for testing
+         */
+        @VisibleForTesting
+        public IFaceService getFaceService() {
+            return IFaceService.Stub.asInterface(
+                    ServiceManager.getService(Context.FACE_SERVICE));
+        }
+
+        /**
+         * Allows us to mock IrisService for testing
+         */
+        @VisibleForTesting
+        public IIrisService getIrisService() {
+            return IIrisService.Stub.asInterface(
+                    ServiceManager.getService(Context.IRIS_SERVICE));
+        }
+
+        @VisibleForTesting
+        public AppOpsManager getAppOps(Context context) {
+            return context.getSystemService(AppOpsManager.class);
+        }
+
+        /**
+         * Allows to ignore HIDL HALs on debug builds based on a secure setting.
+         */
+        @VisibleForTesting
+        public boolean isHidlDisabled(Context context) {
+            if (Build.IS_ENG || Build.IS_USERDEBUG) {
+                return Settings.Secure.getIntForUser(context.getContentResolver(),
+                        SETTING_HIDL_DISABLED, DEFAULT_HIDL_DISABLED, UserHandle.USER_CURRENT) == 1;
+            }
+            return false;
+        }
+
+        /**
+         * Allows to test with various fingerprint aidl instances.
+         */
+        @VisibleForTesting
+        public String[] getFingerprintAidlInstances() {
+            return ServiceManager.getDeclaredInstances(IFingerprint.DESCRIPTOR);
+        }
+
+        /**
+         * Allows to test with various face aidl instances.
+         */
+        @VisibleForTesting
+        public String[] getFaceAidlInstances() {
+            return ServiceManager.getDeclaredInstances(IFace.DESCRIPTOR);
+        }
+
+        /**
+         * Allows to test with handlers.
+         */
+        public BiometricHandlerProvider getBiometricHandlerProvider() {
+            return BiometricHandlerProvider.getInstance();
+        }
+    }
+
+    private final class AuthServiceImpl extends IAuthService.Stub {
+        @android.annotation.EnforcePermission(android.Manifest.permission.TEST_BIOMETRIC)
+        @Override
+        public ITestSession createTestSession(int sensorId, @NonNull ITestSessionCallback callback,
+                @NonNull String opPackageName) throws RemoteException {
+
+            super.createTestSession_enforcePermission();
+
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                return mInjector.getBiometricService()
+                        .createTestSession(sensorId, callback, opPackageName);
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+        }
+
+        @android.annotation.EnforcePermission(android.Manifest.permission.TEST_BIOMETRIC)
+        @Override
+        public List<SensorPropertiesInternal> getSensorProperties(String opPackageName)
+                throws RemoteException {
+
+            super.getSensorProperties_enforcePermission();
+
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                // Get the result from BiometricService, since it is the source of truth for all
+                // biometric sensors.
+                return mInjector.getBiometricService().getSensorProperties(opPackageName);
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+        }
+
+        @android.annotation.EnforcePermission(android.Manifest.permission.TEST_BIOMETRIC)
+        @Override
+        public String getUiPackage() {
+
+            super.getUiPackage_enforcePermission();
+
+            return getContext().getResources()
+                    .getString(R.string.config_biometric_prompt_ui_package);
+        }
+
+        @Override
+        public long authenticate(IBinder token, long sessionId, int userId,
+                IBiometricServiceReceiver receiver, String opPackageName, PromptInfo promptInfo)
+                throws RemoteException {
+            // Only allow internal clients to authenticate with a different userId.
+            final int callingUserId = UserHandle.getCallingUserId();
+            final int callingUid = Binder.getCallingUid();
+            final int callingPid = Binder.getCallingPid();
+            if (userId == callingUserId) {
+                checkPermission();
+            } else {
+                Slog.w(TAG, "User " + callingUserId + " is requesting authentication of userid: "
+                        + userId);
+                checkInternalPermission();
+            }
+
+            if (!checkAppOps(callingUid, opPackageName, "authenticate()")) {
+                authenticateFastFail("Denied by app ops: " + opPackageName, receiver);
+                return -1;
+            }
+
+            if (token == null || receiver == null || opPackageName == null || promptInfo == null) {
+                authenticateFastFail(
+                        "Unable to authenticate, one or more null arguments", receiver);
+                return -1;
+            }
+
+            if (!Utils.isForeground(callingUid, callingPid)) {
+                authenticateFastFail("Caller is not foreground: " + opPackageName, receiver);
+                return -1;
+            }
+
+            if (promptInfo.containsTestConfigurations()) {
+                if (getContext().checkCallingOrSelfPermission(TEST_BIOMETRIC)
+                        != PackageManager.PERMISSION_GRANTED) {
+                    checkInternalPermission();
+                }
+            }
+
+            // Only allow internal clients to enable non-public options.
+            if (promptInfo.containsPrivateApiConfigurations()) {
+                checkInternalPermission();
+            }
+            if (promptInfo.containsSetLogoApiConfigurations()) {
+                checkManageBiometricPermission();
+            }
+
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                VirtualDeviceManagerInternal vdm = getLocalService(
+                        VirtualDeviceManagerInternal.class);
+                if (vdm != null) {
+                    vdm.onAuthenticationPrompt(callingUid);
+                }
+                return mBiometricService.authenticate(
+                        token, sessionId, userId, receiver, opPackageName, promptInfo);
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+        }
+
+        private void authenticateFastFail(String message, IBiometricServiceReceiver receiver) {
+            // notify caller in cases where authentication is aborted before calling into
+            // IBiometricService without raising an exception
+            Slog.e(TAG, "authenticateFastFail: " + message);
+            try {
+                receiver.onError(TYPE_NONE, BIOMETRIC_ERROR_CANCELED, 0 /*vendorCode */);
+            } catch (RemoteException e) {
+                Slog.e(TAG, "authenticateFastFail failed to notify caller", e);
+            }
+        }
+
+        @Override
+        public void cancelAuthentication(IBinder token, String opPackageName, long requestId)
+                throws RemoteException {
+            checkPermission();
+
+            if (token == null || opPackageName == null) {
+                Slog.e(TAG, "Unable to cancel authentication, one or more null arguments");
+                return;
+            }
+
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                mBiometricService.cancelAuthentication(token, opPackageName, requestId);
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+        }
+
+        @Override
+        public int canAuthenticate(String opPackageName, int userId,
+                @Authenticators.Types int authenticators) throws RemoteException {
+
+            // Only allow internal clients to call canAuthenticate with a different userId.
+            final int callingUserId = UserHandle.getCallingUserId();
+
+            if (userId != callingUserId) {
+                checkInternalPermission();
+            } else {
+                checkPermission();
+            }
+
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                final int result = mBiometricService.canAuthenticate(
+                        opPackageName, userId, callingUserId, authenticators);
+                Slog.d(TAG, "canAuthenticate"
+                        + ", userId: " + userId
+                        + ", callingUserId: " + callingUserId
+                        + ", authenticators: " + authenticators
+                        + ", result: " + result);
+                return result;
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+        }
+
+        @Override
+        public long getLastAuthenticationTime(int userId,
+                @Authenticators.Types int authenticators) throws RemoteException {
+            // Only allow internal clients to call getLastAuthenticationTime with a different
+            // userId.
+            final int callingUserId = UserHandle.getCallingUserId();
+
+            if (userId != callingUserId) {
+                checkInternalPermission();
+            } else {
+                checkPermission();
+            }
+
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                // We can't do this above because we need the READ_DEVICE_CONFIG permission, which
+                // the calling user may not possess.
+                if (!Flags.lastAuthenticationTime()) {
+                    throw new UnsupportedOperationException();
+                }
+
+                return mBiometricService.getLastAuthenticationTime(userId, authenticators);
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+        }
+
+        @Override
+        public boolean hasEnrolledBiometrics(int userId, String opPackageName)
+                throws RemoteException {
+            checkInternalPermission();
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                return mBiometricService.hasEnrolledBiometrics(userId, opPackageName);
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+        }
+
+        @Override
+        public void registerEnabledOnKeyguardCallback(
+                IBiometricEnabledOnKeyguardCallback callback) throws RemoteException {
+            checkInternalPermission();
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                mBiometricService.registerEnabledOnKeyguardCallback(callback);
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+        }
+
+        @Override
+        public void registerAuthenticationStateListener(AuthenticationStateListener listener)
+                throws RemoteException {
+            checkInternalPermission();
+            final IFingerprintService fingerprintService = mInjector.getFingerprintService();
+            if (fingerprintService != null) {
+                fingerprintService.registerAuthenticationStateListener(listener);
+            }
+            final IFaceService faceService = mInjector.getFaceService();
+            if (faceService != null) {
+                faceService.registerAuthenticationStateListener(listener);
+            }
+        }
+
+        @Override
+        public void unregisterAuthenticationStateListener(AuthenticationStateListener listener)
+                throws RemoteException {
+            checkInternalPermission();
+            final IFingerprintService fingerprintService = mInjector.getFingerprintService();
+            if (fingerprintService != null) {
+                fingerprintService.unregisterAuthenticationStateListener(listener);
+            }
+            final IFaceService faceService = mInjector.getFaceService();
+            if (faceService != null) {
+                faceService.unregisterAuthenticationStateListener(listener);
+            }
+        }
+
+        @Override
+        public void invalidateAuthenticatorIds(int userId, int fromSensorId,
+                IInvalidationCallback callback) throws RemoteException {
+            checkInternalPermission();
+
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                mBiometricService.invalidateAuthenticatorIds(userId, fromSensorId, callback);
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+        }
+
+        @Override
+        public long[] getAuthenticatorIds(int userId) throws RemoteException {
+            // In this method, we're not checking whether the caller is permitted to use face
+            // API because current authenticator ID is leaked (in a more contrived way) via Android
+            // Keystore (android.security.keystore package): the user of that API can create a key
+            // which requires face authentication for its use, and then query the key's
+            // characteristics (hidden API) which returns, among other things, face
+            // authenticator ID which was active at key creation time.
+            //
+            // Reason: The part of Android Keystore which runs inside an app's process invokes this
+            // method in certain cases. Those cases are not always where the developer demonstrates
+            // explicit intent to use biometric functionality. Thus, to avoiding throwing an
+            // unexpected SecurityException this method does not check whether its caller is
+            // permitted to use face API.
+            //
+            // The permission check should be restored once Android Keystore no longer invokes this
+            // method from inside app processes.
+
+            final int callingUserId = UserHandle.getCallingUserId();
+            if (userId != callingUserId) {
+                getContext().enforceCallingOrSelfPermission(USE_BIOMETRIC_INTERNAL,
+                        "Must have " + USE_BIOMETRIC_INTERNAL + " permission.");
+            }
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                return mBiometricService.getAuthenticatorIds(userId);
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+        }
+
+        @Override
+        public void resetLockoutTimeBound(IBinder token, String opPackageName, int fromSensorId,
+                int userId, byte[] hardwareAuthToken) throws RemoteException {
+            checkInternalPermission();
+
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                mBiometricService.resetLockoutTimeBound(token, opPackageName, fromSensorId, userId,
+                        hardwareAuthToken);
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+        }
+
+        @Override
+        public void resetLockout(int userId, byte[] hardwareAuthToken) throws RemoteException {
+            checkInternalPermission();
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                mBiometricService.resetLockout(userId, hardwareAuthToken);
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+        }
+
+        @Override
+        public CharSequence getButtonLabel(
+                int userId,
+                String opPackageName,
+                @Authenticators.Types int authenticators) throws RemoteException {
+
+            // Only allow internal clients to call getButtonLabel with a different userId.
+            final int callingUserId = UserHandle.getCallingUserId();
+
+            if (userId != callingUserId) {
+                checkInternalPermission();
+            } else {
+                checkPermission();
+            }
+
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                @BiometricAuthenticator.Modality final int modality =
+                        mBiometricService.getCurrentModality(
+                                opPackageName, userId, callingUserId, authenticators);
+
+                final String result;
+                switch (getCredentialBackupModality(modality)) {
+                    case BiometricAuthenticator.TYPE_NONE:
+                        result = null;
+                        break;
+                    case BiometricAuthenticator.TYPE_CREDENTIAL:
+                        result = getContext().getString(R.string.screen_lock_app_setting_name);
+                        break;
+                    case BiometricAuthenticator.TYPE_FINGERPRINT:
+                        result = getContext().getString(R.string.fingerprint_app_setting_name);
+                        break;
+                    case BiometricAuthenticator.TYPE_FACE:
+                        result = getContext().getString(R.string.face_app_setting_name);
+                        break;
+                    default:
+                        result = getContext().getString(R.string.biometric_app_setting_name);
+                        break;
+                }
+
+                return result;
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+        }
+
+        @Override
+        public CharSequence getPromptMessage(
+                int userId,
+                String opPackageName,
+                @Authenticators.Types int authenticators) throws RemoteException {
+
+            // Only allow internal clients to call getButtonLabel with a different userId.
+            final int callingUserId = UserHandle.getCallingUserId();
+
+            if (userId != callingUserId) {
+                checkInternalPermission();
+            } else {
+                checkPermission();
+            }
+
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                @BiometricAuthenticator.Modality final int modality =
+                        mBiometricService.getCurrentModality(
+                                opPackageName, userId, callingUserId, authenticators);
+
+                final boolean isCredentialAllowed = Utils.isCredentialRequested(authenticators);
+
+                final String result;
+                switch (getCredentialBackupModality(modality)) {
+                    case BiometricAuthenticator.TYPE_NONE:
+                        result = null;
+                        break;
+
+                    case BiometricAuthenticator.TYPE_CREDENTIAL:
+                        result = getContext().getString(
+                                R.string.screen_lock_dialog_default_subtitle);
+                        break;
+
+                    case BiometricAuthenticator.TYPE_FINGERPRINT:
+                        if (isCredentialAllowed) {
+                            result = getContext().getString(
+                                    R.string.fingerprint_or_screen_lock_dialog_default_subtitle);
+                        } else {
+                            result = getContext().getString(
+                                    R.string.fingerprint_dialog_default_subtitle);
+                        }
+                        break;
+
+                    case BiometricAuthenticator.TYPE_FACE:
+                        if (isCredentialAllowed) {
+                            result = getContext().getString(
+                                    R.string.face_or_screen_lock_dialog_default_subtitle);
+                        } else {
+                            result = getContext().getString(R.string.face_dialog_default_subtitle);
+                        }
+                        break;
+
+                    default:
+                        if (isCredentialAllowed) {
+                            result = getContext().getString(
+                                    R.string.biometric_or_screen_lock_dialog_default_subtitle);
+                        } else {
+                            result = getContext().getString(
+                                    R.string.biometric_dialog_default_subtitle);
+                        }
+                        break;
+                }
+
+                return result;
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+        }
+
+        @Override
+        public CharSequence getSettingName(
+                int userId,
+                String opPackageName,
+                @Authenticators.Types int authenticators) throws RemoteException {
+
+            // Only allow internal clients to call getButtonLabel with a different userId.
+            final int callingUserId = UserHandle.getCallingUserId();
+
+            if (userId != callingUserId) {
+                checkInternalPermission();
+            } else {
+                checkPermission();
+            }
+
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                @BiometricAuthenticator.Modality final int modality =
+                        mBiometricService.getSupportedModalities(authenticators);
+
+                final String result;
+                switch (modality) {
+                    // Handle the case of a single supported modality.
+                    case BiometricAuthenticator.TYPE_NONE:
+                        result = null;
+                        break;
+                    case BiometricAuthenticator.TYPE_CREDENTIAL:
+                        result = getContext().getString(R.string.screen_lock_app_setting_name);
+                        break;
+                    case BiometricAuthenticator.TYPE_IRIS:
+                        result = getContext().getString(R.string.biometric_app_setting_name);
+                        break;
+                    case BiometricAuthenticator.TYPE_FINGERPRINT:
+                        result = getContext().getString(R.string.fingerprint_app_setting_name);
+                        break;
+                    case BiometricAuthenticator.TYPE_FACE:
+                        result = getContext().getString(R.string.face_app_setting_name);
+                        break;
+
+                    // Handle other possible modality combinations.
+                    default:
+                        if ((modality & BiometricAuthenticator.TYPE_CREDENTIAL) == 0) {
+                            // 2+ biometric modalities are supported (but not device credential).
+                            result = getContext().getString(R.string.biometric_app_setting_name);
+                        } else {
+                            @BiometricAuthenticator.Modality final int biometricModality =
+                                    modality & ~BiometricAuthenticator.TYPE_CREDENTIAL;
+                            if (biometricModality == BiometricAuthenticator.TYPE_FINGERPRINT) {
+                                // Only device credential and fingerprint are supported.
+                                result = getContext().getString(
+                                        R.string.fingerprint_or_screen_lock_app_setting_name);
+                            } else if (biometricModality == BiometricAuthenticator.TYPE_FACE) {
+                                // Only device credential and face are supported.
+                                result = getContext().getString(
+                                        R.string.face_or_screen_lock_app_setting_name);
+                            } else {
+                                // Device credential and 1+ other biometric(s) are supported.
+                                result = getContext().getString(
+                                        R.string.biometric_or_screen_lock_app_setting_name);
+                            }
+                        }
+                        break;
+                }
+                return result;
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+        }
+    }
+
+    public AuthService(Context context) {
+        this(context, new Injector());
+    }
+
+    public AuthService(Context context, Injector injector) {
+        super(context);
+
+        mInjector = injector;
+        mImpl = new AuthServiceImpl();
+    }
+
+
+    /**
+     * Registration of all HIDL and AIDL biometric HALs starts here.
+     * The flow looks like this:
+     * AuthService
+     * └── .onStart()
+     *     └── .registerAuthenticators(...)
+     *         ├── FaceService.registerAuthenticators(...)
+     *         │   └── for (p : serviceProviders)
+     *         │       └── for (s : p.sensors)
+     *         │           └── BiometricService.registerAuthenticator(s)
+     *         │
+     *         ├── FingerprintService.registerAuthenticators(...)
+     *         │   └── for (p : serviceProviders)
+     *         │       └── for (s : p.sensors)
+     *         │           └── BiometricService.registerAuthenticator(s)
+     *         │
+     *         └── IrisService.registerAuthenticators(...)
+     *             └── for (p : serviceProviders)
+     *                 └── for (s : p.sensors)
+     *                     └── BiometricService.registerAuthenticator(s)
+     */
+    @Override
+    public void onStart() {
+        mBiometricService = mInjector.getBiometricService();
+
+        final SensorConfig[] hidlConfigs;
+        if (!mInjector.isHidlDisabled(getContext())) {
+            final int firstApiLevel = SystemProperties.getInt(SYSPROP_FIRST_API_LEVEL, 0);
+            final int apiLevel = SystemProperties.getInt(SYSPROP_API_LEVEL, firstApiLevel);
+            String[] configStrings = mInjector.getConfiguration(getContext());
+            if (configStrings.length == 0) {
+                // For backwards compatibility with R where biometrics could work without being
+                // configured in config_biometric_sensors. In the absence of a vendor provided
+                // configuration, we assume the weakest biometric strength (i.e. convenience).
+                Slog.w(TAG, "Found vendor partition without config_biometric_sensors");
+                configStrings = generateRSdkCompatibleConfiguration();
+            }
+            hidlConfigs = new SensorConfig[configStrings.length];
+            for (int i = 0; i < configStrings.length; ++i) {
+                hidlConfigs[i] = new SensorConfig(configStrings[i]);
+            }
+        } else {
+            hidlConfigs = null;
+        }
+
+        if (com.android.server.biometrics.Flags.deHidl()) {
+            registerAuthenticators();
+        } else {
+            // Registers HIDL and AIDL authenticators, but only HIDL configs need to be provided.
+            registerAuthenticators(hidlConfigs);
+
+        }
+
+        mInjector.publishBinderService(this, mImpl);
+    }
+
+    private void registerAuthenticators() {
+        BiometricHandlerProvider handlerProvider = mInjector.getBiometricHandlerProvider();
+
+        handlerProvider.getFingerprintHandler().post(() ->
+                registerFingerprintSensors(mInjector.getFingerprintAidlInstances(),
+                        mInjector.getFingerprintConfiguration(getContext()), getContext(),
+                        mInjector.getFingerprintService()));
+        handlerProvider.getFaceHandler().post(() ->
+                registerFaceSensors(mInjector.getFaceAidlInstances(),
+                        mInjector.getFaceConfiguration(getContext()), getContext(),
+                        mInjector.getFaceService()));
+        registerIrisSensors(mInjector.getIrisConfiguration(getContext()));
+    }
+
+    private void registerIrisSensors(String[] hidlConfigStrings) {
+        final SensorConfig[] hidlConfigs;
+        if (!mInjector.isHidlDisabled(getContext())) {
+            final int firstApiLevel = SystemProperties.getInt(SYSPROP_FIRST_API_LEVEL, 0);
+            final int apiLevel = SystemProperties.getInt(SYSPROP_API_LEVEL, firstApiLevel);
+            if (hidlConfigStrings.length == 0 && apiLevel == Build.VERSION_CODES.R) {
+                // For backwards compatibility with R where biometrics could work without being
+                // configured in config_biometric_sensors. In the absence of a vendor provided
+                // configuration, we assume the weakest biometric strength (i.e. convenience).
+                Slog.w(TAG, "Found R vendor partition without config_biometric_sensors");
+                hidlConfigStrings = generateRSdkCompatibleConfiguration();
+            }
+            hidlConfigs = new SensorConfig[hidlConfigStrings.length];
+            for (int i = 0; i < hidlConfigStrings.length; ++i) {
+                hidlConfigs[i] = new SensorConfig(hidlConfigStrings[i]);
+            }
+        } else {
+            hidlConfigs = null;
+        }
+
+        final List<SensorPropertiesInternal> hidlIrisSensors = new ArrayList<>();
+
+        if (hidlConfigs != null) {
+            for (SensorConfig sensor : hidlConfigs) {
+                switch (sensor.modality) {
+                    case TYPE_IRIS:
+                        hidlIrisSensors.add(getHidlIrisSensorProps(sensor.id, sensor.strength));
+                        break;
+
+                    default:
+                        Slog.e(TAG, "Unknown modality: " + sensor.modality);
+                }
+            }
+        }
+
+        final IIrisService irisService = mInjector.getIrisService();
+        if (irisService != null) {
+            try {
+                irisService.registerAuthenticators(hidlIrisSensors);
+            } catch (RemoteException e) {
+                Slog.e(TAG, "RemoteException when registering iris authenticators", e);
+            }
+        } else if (hidlIrisSensors.size() > 0) {
+            Slog.e(TAG, "HIDL iris configuration exists, but IrisService is null.");
+        }
+    }
+
+    /**
+     * This method is invoked on {@link BiometricHandlerProvider.mFaceHandler}.
+     */
+    private static void registerFaceSensors(final String[] faceAidlInstances,
+            final String[] hidlConfigStrings, final Context context,
+            final IFaceService faceService) {
+        final FaceSensorConfigurations mFaceSensorConfigurations =
+                new FaceSensorConfigurations(hidlConfigStrings != null
+                        && hidlConfigStrings.length > 0);
+
+        if (hidlConfigStrings != null && hidlConfigStrings.length > 0) {
+            mFaceSensorConfigurations.addHidlConfigs(hidlConfigStrings, context);
+        }
+
+        if (faceAidlInstances != null && faceAidlInstances.length > 0) {
+            mFaceSensorConfigurations.addAidlConfigs(faceAidlInstances,
+                    name -> IFace.Stub.asInterface(Binder.allowBlocking(
+                            ServiceManager.waitForDeclaredService(name))));
+        }
+
+        if (faceService != null) {
+            try {
+                faceService.registerAuthenticatorsLegacy(mFaceSensorConfigurations);
+            } catch (RemoteException e) {
+                Slog.e(TAG, "RemoteException when registering face authenticators", e);
+            }
+        }  else if (mFaceSensorConfigurations.hasSensorConfigurations()) {
+            Slog.e(TAG, "Face configuration exists, but FaceService is null.");
+        }
+    }
+
+    /**
+     * This method is invoked on {@link BiometricHandlerProvider.mFingerprintHandler}.
+     */
+    private static void registerFingerprintSensors(final String[] fingerprintAidlInstances,
+            final String[] hidlConfigStrings, final Context context,
+            final IFingerprintService fingerprintService) {
+        final FingerprintSensorConfigurations mFingerprintSensorConfigurations =
+                new FingerprintSensorConfigurations(!(hidlConfigStrings != null
+                        && hidlConfigStrings.length > 0));
+
+        if (hidlConfigStrings != null && hidlConfigStrings.length > 0) {
+            mFingerprintSensorConfigurations.addHidlSensors(hidlConfigStrings, context);
+        }
+
+        if (fingerprintAidlInstances != null && fingerprintAidlInstances.length > 0) {
+            mFingerprintSensorConfigurations.addAidlSensors(fingerprintAidlInstances,
+                    name -> IFingerprint.Stub.asInterface(Binder.allowBlocking(
+                            ServiceManager.waitForDeclaredService(name))));
+        }
+
+        if (fingerprintService != null) {
+            try {
+                fingerprintService.registerAuthenticatorsLegacy(mFingerprintSensorConfigurations);
+            } catch (RemoteException e) {
+                Slog.e(TAG, "RemoteException when registering fingerprint authenticators", e);
+            }
+        }  else if (mFingerprintSensorConfigurations.hasSensorConfigurations()) {
+            Slog.e(TAG, "Fingerprint configuration exists, but FingerprintService is null.");
+        }
+    }
+
+    /**
+     * Generates an array of string configs with entries that correspond to the biometric features
+     * declared on the device. Returns an empty array if no biometric features are declared.
+     * Biometrics are assumed to be of the weakest strength class, i.e. convenience.
+     */
+    private @NonNull String[] generateRSdkCompatibleConfiguration() {
+        final PackageManager pm = getContext().getPackageManager();
+        final ArrayList<String> modalities = new ArrayList<>();
+        if (pm.hasSystemFeature(PackageManager.FEATURE_FINGERPRINT)) {
+            modalities.add(String.valueOf(BiometricAuthenticator.TYPE_FINGERPRINT));
+        }
+        if (pm.hasSystemFeature(PackageManager.FEATURE_FACE)) {
+            modalities.add(String.valueOf(BiometricAuthenticator.TYPE_FACE));
+        }
+        final String strength = String.valueOf(Authenticators.BIOMETRIC_STRONG);
+        final String[] configStrings = new String[modalities.size()];
+        for (int i = 0; i < modalities.size(); ++i) {
+            final String id = String.valueOf(i);
+            final String modality = modalities.get(i);
+            configStrings[i] = String.join(":" /* delimiter */, id, modality, strength);
+        }
+        Slog.d(TAG, "Generated config_biometric_sensors: " + Arrays.toString(configStrings));
+        return configStrings;
+    }
+
+    /**
+     * Registers HIDL and AIDL authenticators for all of the available modalities.
+     *
+     * @param hidlSensors Array of {@link SensorConfig} configuration for all of the HIDL sensors
+     *                    available on the device. This array may contain configuration for
+     *                    different modalities and different sensors of the same modality in
+     *                    arbitrary order. Can be null if no HIDL sensors exist on the device.
+     */
+    private void registerAuthenticators(@Nullable SensorConfig[] hidlSensors) {
+        List<FingerprintSensorPropertiesInternal> hidlFingerprintSensors = new ArrayList<>();
+        List<FaceSensorPropertiesInternal> hidlFaceSensors = new ArrayList<>();
+        // Iris doesn't have IrisSensorPropertiesInternal, using SensorPropertiesInternal instead.
+        List<SensorPropertiesInternal> hidlIrisSensors = new ArrayList<>();
+
+        if (hidlSensors != null) {
+            for (SensorConfig sensor : hidlSensors) {
+                Slog.d(TAG, "Registering HIDL ID: " + sensor.id + " Modality: " + sensor.modality
+                        + " Strength: " + sensor.strength);
+                switch (sensor.modality) {
+                    case TYPE_FINGERPRINT:
+                        hidlFingerprintSensors.add(
+                                getHidlFingerprintSensorProps(sensor.id, sensor.strength));
+                        break;
+
+                    case TYPE_FACE:
+                        hidlFaceSensors.add(getHidlFaceSensorProps(sensor.id, sensor.strength));
+                        break;
+
+                    case TYPE_IRIS:
+                        hidlIrisSensors.add(getHidlIrisSensorProps(sensor.id, sensor.strength));
+                        break;
+
+                    default:
+                        Slog.e(TAG, "Unknown modality: " + sensor.modality);
+                }
+            }
+        }
+
+        final IFingerprintService fingerprintService = mInjector.getFingerprintService();
+        if (fingerprintService != null) {
+            try {
+                fingerprintService.registerAuthenticators(hidlFingerprintSensors);
+            } catch (RemoteException e) {
+                Slog.e(TAG, "RemoteException when registering fingerprint authenticators", e);
+            }
+        } else if (hidlFingerprintSensors.size() > 0) {
+            Slog.e(TAG, "HIDL fingerprint configuration exists, but FingerprintService is null.");
+        }
+
+        final IFaceService faceService = mInjector.getFaceService();
+        if (faceService != null) {
+            try {
+                faceService.registerAuthenticators(hidlFaceSensors);
+            } catch (RemoteException e) {
+                Slog.e(TAG, "RemoteException when registering face authenticators", e);
+            }
+        } else if (hidlFaceSensors.size() > 0) {
+            Slog.e(TAG, "HIDL face configuration exists, but FaceService is null.");
+        }
+
+        final IIrisService irisService = mInjector.getIrisService();
+        if (irisService != null) {
+            try {
+                irisService.registerAuthenticators(hidlIrisSensors);
+            } catch (RemoteException e) {
+                Slog.e(TAG, "RemoteException when registering iris authenticators", e);
+            }
+        } else if (hidlIrisSensors.size() > 0) {
+            Slog.e(TAG, "HIDL iris configuration exists, but IrisService is null.");
+        }
+    }
+
+    private void checkInternalPermission() {
+        getContext().enforceCallingOrSelfPermission(USE_BIOMETRIC_INTERNAL,
+                "Must have USE_BIOMETRIC_INTERNAL permission");
+    }
+
+    private void checkManageBiometricPermission() {
+        getContext().enforceCallingOrSelfPermission(SET_BIOMETRIC_DIALOG_LOGO,
+                "Must have SET_BIOMETRIC_DIALOG_LOGO permission");
+    }
+
+    private void checkPermission() {
+        if (getContext().checkCallingOrSelfPermission(USE_FINGERPRINT)
+                != PackageManager.PERMISSION_GRANTED) {
+            getContext().enforceCallingOrSelfPermission(USE_BIOMETRIC,
+                    "Must have USE_BIOMETRIC permission");
+        }
+    }
+
+    private boolean checkAppOps(int uid, String opPackageName, String reason) {
+        return mInjector.getAppOps(getContext()).noteOp(AppOpsManager.OP_USE_BIOMETRIC, uid,
+                opPackageName, null /* attributionTag */, reason) == AppOpsManager.MODE_ALLOWED;
+    }
+
+    @BiometricAuthenticator.Modality
+    private static int getCredentialBackupModality(@BiometricAuthenticator.Modality int modality) {
+        return modality == BiometricAuthenticator.TYPE_CREDENTIAL
+                ? modality : (modality & ~BiometricAuthenticator.TYPE_CREDENTIAL);
+    }
+
+
+    private FingerprintSensorPropertiesInternal getHidlFingerprintSensorProps(int sensorId,
+            @BiometricManager.Authenticators.Types int strength) {
+        // The existence of config_udfps_sensor_props indicates that the sensor is UDFPS.
+        final int[] udfpsProps = getContext().getResources().getIntArray(
+                com.android.internal.R.array.config_udfps_sensor_props);
+
+        // Non-empty workaroundLocations indicates that the sensor is SFPS.
+        final List<SensorLocationInternal> workaroundLocations =
+                getWorkaroundSensorProps(getContext());
+
+        final boolean isUdfps = !ArrayUtils.isEmpty(udfpsProps);
+
+        // config_is_powerbutton_fps indicates whether device has a power button fingerprint sensor.
+        final boolean isPowerbuttonFps = getContext().getResources().getBoolean(
+                R.bool.config_is_powerbutton_fps);
+
+        final @FingerprintSensorProperties.SensorType int sensorType;
+        if (isUdfps) {
+            sensorType = FingerprintSensorProperties.TYPE_UDFPS_OPTICAL;
+        } else if (isPowerbuttonFps) {
+            sensorType = FingerprintSensorProperties.TYPE_POWER_BUTTON;
+        } else {
+            sensorType = FingerprintSensorProperties.TYPE_REAR;
+        }
+
+        // IBiometricsFingerprint@2.1 does not manage timeout below the HAL, so the Gatekeeper HAT
+        // cannot be checked.
+        final boolean resetLockoutRequiresHardwareAuthToken = false;
+        final int maxEnrollmentsPerUser = getContext().getResources().getInteger(
+                R.integer.config_fingerprintMaxTemplatesPerUser);
+
+        final List<ComponentInfoInternal> componentInfo = new ArrayList<>();
+        if (isUdfps && udfpsProps.length == 3) {
+            return new FingerprintSensorPropertiesInternal(sensorId,
+                    Utils.authenticatorStrengthToPropertyStrength(strength), maxEnrollmentsPerUser,
+                    componentInfo, sensorType, true /* halControlsIllumination */,
+                    resetLockoutRequiresHardwareAuthToken,
+                    List.of(new SensorLocationInternal("" /* display */, udfpsProps[0],
+                            udfpsProps[1], udfpsProps[2])));
+        } else if (!workaroundLocations.isEmpty()) {
+            return new FingerprintSensorPropertiesInternal(sensorId,
+                    Utils.authenticatorStrengthToPropertyStrength(strength), maxEnrollmentsPerUser,
+                    componentInfo, sensorType, false /* halControlsIllumination */,
+                    resetLockoutRequiresHardwareAuthToken,
+                    workaroundLocations);
+        } else {
+            return new FingerprintSensorPropertiesInternal(sensorId,
+                    Utils.authenticatorStrengthToPropertyStrength(strength), maxEnrollmentsPerUser,
+                    componentInfo, sensorType, resetLockoutRequiresHardwareAuthToken);
+        }
+    }
+
+    private FaceSensorPropertiesInternal getHidlFaceSensorProps(int sensorId,
+            @BiometricManager.Authenticators.Types int strength) {
+        final boolean supportsSelfIllumination = getContext().getResources().getBoolean(
+                R.bool.config_faceAuthSupportsSelfIllumination);
+        final int maxTemplatesAllowed = getContext().getResources().getInteger(
+                R.integer.config_faceMaxTemplatesPerUser);
+        final List<ComponentInfoInternal> componentInfo = new ArrayList<>();
+        final boolean supportsFaceDetect = false;
+        final boolean resetLockoutRequiresChallenge = true;
+        return new FaceSensorPropertiesInternal(sensorId,
+                Utils.authenticatorStrengthToPropertyStrength(strength), maxTemplatesAllowed,
+                componentInfo, FaceSensorProperties.TYPE_UNKNOWN, supportsFaceDetect,
+                supportsSelfIllumination, resetLockoutRequiresChallenge);
+    }
+
+    private SensorPropertiesInternal getHidlIrisSensorProps(int sensorId,
+            @BiometricManager.Authenticators.Types int strength) {
+        final int maxEnrollmentsPerUser = 1;
+        final List<ComponentInfoInternal> componentInfo = new ArrayList<>();
+        final boolean resetLockoutRequiresHardwareAuthToken = false;
+        final boolean resetLockoutRequiresChallenge = false;
+        return new SensorPropertiesInternal(sensorId,
+                Utils.authenticatorStrengthToPropertyStrength(strength), maxEnrollmentsPerUser,
+                componentInfo, resetLockoutRequiresHardwareAuthToken,
+                resetLockoutRequiresChallenge);
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/fingerprint/FingerprintService.java b/services/core/java/com/android/server/biometrics/sensors/fingerprint/FingerprintService.java
index 1ba12134ab29..41a7eb0acffa 100644
--- a/services/core/java/com/android/server/biometrics/sensors/fingerprint/FingerprintService.java
+++ b/services/core/java/com/android/server/biometrics/sensors/fingerprint/FingerprintService.java
@@ -913,8 +913,9 @@ public class FingerprintService extends SystemService {
                         filteredInstances = filterAvailableHalInstances(hidlSensors, aidlSensors);
 
                 final List<ServiceProvider> providers = new ArrayList<>();
-                providers.addAll(getHidlProviders(filteredInstances.first));
                 providers.addAll(getAidlProviders(filteredInstances.second));
+                if (providers.isEmpty())
+                    providers.addAll(getHidlProviders(filteredInstances.first));
 
                 return providers;
             });
diff --git a/services/core/java/com/android/server/biometrics/sensors/fingerprint/aidl/FingerprintProvider.java b/services/core/java/com/android/server/biometrics/sensors/fingerprint/aidl/FingerprintProvider.java
index 158179dca499..5c822095bee4 100644
--- a/services/core/java/com/android/server/biometrics/sensors/fingerprint/aidl/FingerprintProvider.java
+++ b/services/core/java/com/android/server/biometrics/sensors/fingerprint/aidl/FingerprintProvider.java
@@ -38,6 +38,7 @@ import android.hardware.biometrics.common.ComponentInfo;
 import android.hardware.biometrics.fingerprint.IFingerprint;
 import android.hardware.biometrics.fingerprint.PointerContext;
 import android.hardware.biometrics.fingerprint.SensorProps;
+import android.hardware.biometrics.fingerprint.SensorLocation;
 import android.hardware.fingerprint.Fingerprint;
 import android.hardware.fingerprint.FingerprintAuthenticateOptions;
 import android.hardware.fingerprint.FingerprintEnrollOptions;
@@ -249,9 +250,32 @@ public class FingerprintProvider implements IBinder.DeathRecipient, ServiceProvi
         } else {
             final List<SensorLocationInternal> workaroundLocations =
                     getWorkaroundSensorProps(mContext);
+android.util.Log.e("PHH-Enroll", "Poping AIDL fp provider");
 
             for (SensorProps prop : props) {
                 final int sensorId = prop.commonProps.sensorId;
+                SensorLocation[] locations = prop.sensorLocations;
+
+                android.util.Log.e("PHH-Enroll", "Got fp props -- pre");
+                for(SensorLocation loc: locations) {
+                    android.util.Log.e("PHH-Enroll", " - " + loc.sensorLocationX + ", " + loc.sensorLocationY + ", " +loc.sensorRadius + ", disp =" + loc.display + ", shape " + loc.sensorShape);
+                }
+                if (locations.length == 1 && locations[0].sensorLocationX == 0) {
+                    int[] otherValues = com.android.server.biometrics.AuthService.dynamicUdfpsProps(context);
+                    if (otherValues.length > 0) {
+                        SensorLocation loc = new SensorLocation();
+                        loc.sensorLocationX = otherValues[0];
+                        loc.sensorLocationY = otherValues[1];
+                        loc.sensorRadius = otherValues[2];
+                        locations[0] = loc;
+                    }
+                }
+
+                android.util.Log.e("PHH-Enroll", "Got fp props -- post");
+                for(SensorLocation loc: locations) {
+                    android.util.Log.e("PHH-Enroll", " - " + loc.sensorLocationX + ", " + loc.sensorLocationY + ", " +loc.sensorRadius + ", disp =" + loc.display + ", shape " + loc.sensorShape);
+                }
+
                 final List<ComponentInfoInternal> componentInfo = new ArrayList<>();
                 if (prop.commonProps.componentInfo != null) {
                     for (ComponentInfo info : prop.commonProps.componentInfo) {
@@ -269,7 +293,7 @@ public class FingerprintProvider implements IBinder.DeathRecipient, ServiceProvi
                                 prop.halControlsIllumination,
                                 true /* resetLockoutRequiresHardwareAuthToken */,
                                 !workaroundLocations.isEmpty() ? workaroundLocations :
-                                        Arrays.stream(prop.sensorLocations).map(
+                                        Arrays.stream(locations).map(
                                                         location -> new SensorLocationInternal(
                                                                 location.display,
                                                                 location.sensorLocationX,
-- 
2.34.1

